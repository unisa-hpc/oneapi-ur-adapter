<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>oneAPI UR Adapters Download</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;max-width:980px;margin:40px auto;padding:0 16px}
    .card{border:1px solid #ddd;border-radius:14px;padding:16px}
    .grid{display:grid;grid-template-columns:1fr;gap:12px}
    @media(min-width:860px){.grid{grid-template-columns:repeat(5,1fr)}}
    label{font-weight:600;display:block;margin:0 0 6px}
    select{width:100%;padding:10px;border-radius:10px;border:1px solid #bbb}
    a.btn{display:inline-block;margin-top:12px;padding:10px 14px;border-radius:10px;border:1px solid #000;text-decoration:none}
    pre{margin-top:12px;padding:12px;border-radius:12px;border:1px solid #ddd;overflow:auto}
    .warn{color:#b45309;font-weight:700}
    .muted{color:#555}
  </style>
</head>
<body>
  <h1>Download oneAPI UR Adapters</h1>
  <p class="muted">Choose configuration and download the matching installer. Add new backends/OS/versions by editing <code>manifest.json</code> only.</p>

  <div class="card">
    <div class="grid">
      <div><label for="oneapi">oneAPI</label><select id="oneapi"></select></div>
      <div><label for="vendor">Vendor</label><select id="vendor"></select></div>
      <div><label for="backend">Backend</label><select id="backend"></select></div>
      <div><label for="os">OS</label><select id="os"></select></div>
      <div><label for="arch">Arch</label><select id="arch"></select></div>
    </div>

    <div style="margin-top:10px">
      <a id="downloadBtn" class="btn" href="#">Download</a>
      <a id="releaseBtn" class="btn" href="#" target="_blank" rel="noreferrer">View release</a>
      <span id="status" class="warn" style="margin-left:10px"></span>
    </div>

    <pre><code id="cmd"></code></pre>
    <p class="muted">Tip: <code>chmod +x file.sh &amp;&amp; ./file.sh --oneapi-root /opt/intel/oneapi</code></p>
  </div>

<script>
const $ = (id) => document.getElementById(id);
const uniq = (arr) => [...new Set(arr)].sort();

function releaseUrl(owner, repo, tag){
  return `https://github.com/${owner}/${repo}/releases/tag/${tag}`;
}
function assetUrl(owner, repo, tag, filename){
  return `https://github.com/${owner}/${repo}/releases/download/${tag}/${encodeURIComponent(filename)}`;
}

function setOptionsKeepIfPossible(sel, values, preferred){
  sel.innerHTML = "";
  values.forEach(v => {
    const o = document.createElement("option");
    o.value = v;
    o.textContent = v;
    sel.appendChild(o);
  });

  // Keep previous value if still valid, else pick preferred, else first
  if (values.includes(preferred)) {
    sel.value = preferred;
  } else if (values.length > 0) {
    sel.value = values[0];
  } else {
    sel.value = ""; // no options
  }
}

function getSelection(){
  return {
    oneapi: $("oneapi").value,
    vendor: $("vendor").value,
    backend: $("backend").value,
    os: $("os").value,
    arch: $("arch").value
  };
}

// Filter items using only fields that are currently set (non-empty)
function filterByPartial(items, s){
  return items.filter(it =>
    (!s.oneapi  || it.oneapi_version === s.oneapi) &&
    (!s.vendor || it.vendor        === s.vendor) &&
    (!s.backend|| it.backend       === s.backend) &&
    (!s.os     || it.os            === s.os) &&
    (!s.arch   || it.arch          === s.arch)
  );
}

function update(manifest){
  const s = getSelection();
  const items = manifest.items.filter(it =>
    it.oneapi_version === s.oneapi &&
    it.vendor === s.vendor &&
    it.backend === s.backend &&
    it.os === s.os &&
    it.arch === s.arch
  );

  const status = $("status");

  if (items.length !== 1){
    status.textContent = items.length === 0
      ? "No artifact for this selection."
      : "Selection is ambiguous (manifest has duplicates).";
    $("downloadBtn").href = "#";
    $("releaseBtn").href = "#";
    $("cmd").textContent = "# No unique match";
    return;
  }

  status.textContent = "";
  const it = items[0];
  const url = assetUrl(manifest.owner, manifest.repo, it.tag, it.filename);

  $("downloadBtn").href = url;
  $("releaseBtn").href = releaseUrl(manifest.owner, manifest.repo, it.tag);

  const shaLine = it.sha256 && it.sha256 !== "PUT_SHA256_HERE"
    ? `echo "${it.sha256}  ${it.filename}" | sha256sum -c -\n`
    : `# (optional) add sha256 in manifest.json to enable verification\n`;

  $("cmd").textContent =
`# Download
curl -L -O "${url}"

# Verify
${shaLine}
# Install
chmod +x "${it.filename}"
./"${it.filename}" --oneapi-root /opt/intel/oneapi
`;
}

// Recompute dropdown options based on current selection, but for each dropdown
// we compute valid options while "ignoring" that dropdown's current value.
// This makes each dropdown dependent on the others.
function refreshDropdowns(manifest, changedId){
  const items = manifest.items;

  // Current values BEFORE we rewrite options (so we can try to keep them)
  const current = getSelection();

  function optionsFor(field){
    const partial = {...current};

    // Ignore the field we are computing options for:
    if (field === "oneapi")  partial.oneapi  = "";
    if (field === "vendor")  partial.vendor  = "";
    if (field === "backend") partial.backend = "";
    if (field === "os")      partial.os      = "";
    if (field === "arch")    partial.arch    = "";

    const filtered = filterByPartial(items, partial);

    if (field === "oneapi")  return uniq(filtered.map(x => x.oneapi_version));
    if (field === "vendor")  return uniq(filtered.map(x => x.vendor));
    if (field === "backend") return uniq(filtered.map(x => x.backend));
    if (field === "os")      return uniq(filtered.map(x => x.os));
    if (field === "arch")    return uniq(filtered.map(x => x.arch));
    return [];
  }

  // Compute valid options for each dropdown given the others
  const oneapiOpts  = optionsFor("oneapi");
  const vendorOpts  = optionsFor("vendor");
  const backendOpts = optionsFor("backend");
  const osOpts      = optionsFor("os");
  const archOpts    = optionsFor("arch");

  // Rewrite dropdowns, trying to keep current selection where possible
  setOptionsKeepIfPossible($("oneapi"),  oneapiOpts,  current.oneapi);
  setOptionsKeepIfPossible($("vendor"),  vendorOpts,  current.vendor);
  setOptionsKeepIfPossible($("backend"), backendOpts, current.backend);
  setOptionsKeepIfPossible($("os"),      osOpts,      current.os);
  setOptionsKeepIfPossible($("arch"),    archOpts,    current.arch);

  // After rewriting, run update()
  update(manifest);
}

(async function main(){
  const manifest = await (await fetch("./manifest.json", {cache:"no-store"})).json();

  // Initial population: start with global uniques
  setOptionsKeepIfPossible($("oneapi"),  uniq(manifest.items.map(x => x.oneapi_version)), "");
  setOptionsKeepIfPossible($("vendor"),  uniq(manifest.items.map(x => x.vendor)), "");
  setOptionsKeepIfPossible($("backend"), uniq(manifest.items.map(x => x.backend)), "");
  setOptionsKeepIfPossible($("os"),      uniq(manifest.items.map(x => x.os)), "");
  setOptionsKeepIfPossible($("arch"),    uniq(manifest.items.map(x => x.arch)), "");

  // First dependency pass to constrain options
  refreshDropdowns(manifest, null);

  // On change: recompute all dropdowns to enforce dependencies
  ["oneapi","vendor","backend","os","arch"].forEach(id => {
    $(id).addEventListener("change", () => refreshDropdowns(manifest, id));
  });
})();
</script>
</body>
</html>
